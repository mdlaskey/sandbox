import cv2
import numpy as np
from utilities import const, recorder

# returns distance between loc1 and loc2
# locs - two-element tuples of integers x,y
def dist(loc1, loc2):
    return ((loc1[0] - loc2[0])**2 + (loc1[1] - loc2[1])**2)**(1.0/2.0)

def dist_squared(loc1, loc2):
    diffx = loc1[0] - loc2[0]
    diffy = loc1[1] - loc2[1]
    return diffx * diffx + diffy * diffy 

# Given a point, maps pixel to val if in range
# map - image
# lower - 3 tuple lower bound
# upper - 3 tuple upper bound
# val - value to replace if in range
# loc - location of pixel x,y
def mapRange(map, loc):
    x, y = loc
    blue, green, red = map[y, x]
    blueLow, greenLow, redLow = (0,0,0)
    blueUp, greenUp, redUp = (130, 130, 130)
    
    if greenLow < green \
            and greenUp > green \
            and blueLow < blue \
            and blueUp > blue \
            and redLow < red \
            and redUp > red:
        ""
        map[y, x] =  [120, 180, 120]
        map[y+1, x] =  [120, 180, 120]
        map[y, x+1] =  [120, 180, 120]
        map[y+1, x+1] =  [120, 180, 120]


# Setting up video capture
vc = cv2.VideoCapture(0)

if vc.isOpened():
    rval, frame = vc.read()
else:
    rval = False

rval, frame = vc.read()


# reading hyperparameters generated by calibrate.py
f = open('hyperparams.txt', 'r')
x = 10
y = 20
maxRedLoc = [int(x) for x in f.readline().split(',') ]
d = int(float(f.readline()))
d_squared = d * d
f.close()

tolerance = 2000

rec = recorder.generate((const.HEIGHT, const.WIDTH))

lower_green = np.array([30,10,0])
upper_green = np.array([70,140,180])

while 1:

    rval, frame = vc.read()
    frame = frame[0+const.OFFSET_Y:const.HEIGHT+const.OFFSET_Y, 0+const.OFFSET_X:const.WIDTH+const.OFFSET_X]
    
    # identify the black ring around disk
    # TODO optimize by ignoring areas that are clearly not the disc (well outside the distance)
    for i in range( int(maxRedLoc[1] - 2*d), int(maxRedLoc[1] + 2*d), 2 ):
        for j in range( int(maxRedLoc[0] - 2*d), int(maxRedLoc[0] + 2*d), 2 ):
            if abs(dist_squared((j, i), maxRedLoc) - d_squared) < 2000:        # 2000 is fault tolerance
                mapRange(frame, (j, i))     # range for determining the dark values in the ring,  map to a green
    
    # convert to hsv
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    
    # apply range threshold to entire image
    mask = cv2.inRange(hsv, lower_green, upper_green)
    mask = 255 - mask
    mask_b = cv2.medianBlur(mask,9)

    cv2.imshow('original', frame)
    #cv2.imshow('hsv', hsv)
    #cv2.imshow('mask', mask)    
    cv2.imshow("preview", mask_b)
    #rec.write(cv2.cvtColor(mask_b, cv2.COLOR_GRAY2BGR))
    #cv2.imwrite('sample.jpg', mask_b)
    key = cv2.waitKey(20)
    if key == 27:
        break

rec.release()
cv2.destroyAllWindows()
